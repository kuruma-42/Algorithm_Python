# baekjoon 1931 회의실 배정 (그리디)
# 한 개의 회의실 이를 사용하고자 하는 N개의 회의에 대하여
# 회의 I에 대해 시작과 끝나는 시간이 주어짐
# 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 '최대' 개수를 찾아보자
# 회의의 수가 100,000이 주어진다. O(n^2)이 되면 시간초과가 생기기 때문에 알고리즘을 사용한다.
# 시작 시간과 끝나는 시간은 2^31 - 1 작거나 같은 자연수 또는 0이다.
# 그리디나 PQ를 사용해야 된다고 판단하고 시작한다.
# 입력 값이 많을 수 있기 때문에 input 대신 readline을 사용한다.
# 끝나는 시간이 빠를수록 여러 개의 회의를 넣을 수 있다.
# 정렬 기준을 끝나는 시간이 빠른 순서대로 정렬한다.
# list.sort(key=lambda x:(x[0],x[1])

import sys
n = int(input())
q = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]
room = []

# 끝나는 시간으로 정렬, 그 후 시작하는 시간으로 정렬
# 정렬하는 표현식 잘 기억할 것
q.sort(key=lambda x: (x[1],x[0]))

# 첫 번째 회의가 끝나는 시간 넣는다.
room.append(q[0][1])
# 두 번째 회의부터 반복
for i in range(1,n):
    # 회의가 끝나는 시간이 다음 회의 시작 시간 보다 같거나 작으면
    if room[-1] <= q[i][0]:
        # 해당 인덱스의 회의가 끝나는 시간을 넣는다.
        room.append(q[i][1])
    # 회의가 끝나는 시간이 다음 회의 시작 시간 보다 크면
    else:
        continue

print(len(room))